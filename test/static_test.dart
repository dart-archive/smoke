// Copyright (c) 2014, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

library smoke.test.static_test;

import 'package:smoke/smoke.dart' show Declaration, PROPERTY, METHOD;
import 'package:smoke/static.dart';
import 'package:unittest/unittest.dart';
import 'common.dart' hide main;
import 'common.dart' as common show main;

// Abstract class used to represent the mixing C&A in the smoke configuration.
abstract class C_with_A {}

// Static configuration that declares only the symbols, getters, methods, and
// super-class relationships we want to preserve. This and the class above
// should be automatically generated by transformers using smoke.
var _config = new StaticConfiguration(
    getters: {
      #i: (o) => o.i,
      #j: (o) => o.j,
      #j2: (o) => o.j2,
      #inc0: (o) => o.inc0,
      #inc1: (o) => o.inc1,
      #inc2: (o) => o.inc2,
    },
    setters: {
      #i: (o, v) { o.i = v; },
      #j2: (o, v) { o.j2 = v; },
    },
    // TODO(sigmund): this could be a const map, but that triggers
    // dartbug.com/17123
    // TODO(sigmund): before doing codegen for this, consider changing smoke's
    // defaults so we don't need to specify obvious things like `int`, or `*:
    // Object`.
    parents: {
      Annot: Object,
      AnnotB: Annot,
      A: Object,
      B: Object,
      C: Object,
      C_with_A: C,
      D: C_with_A,
      E: Object,
      E2: E,
      F: Object,
      F2: F,
      G: Object,
      H: G,
      int: Object,
    },
    declarations: { 
      B: {
        #a: const Declaration(#a, A),
        #w: const Declaration(#w, int, kind: PROPERTY),
        #f: const Declaration(#f, int, isFinal: true),
      },
      A: {
        #i: const Declaration(#i, int),
        #j: const Declaration(#j, int),
        #j2: const Declaration(#j2, int, kind: PROPERTY),
        #inc0: const Declaration(#inc0, Function, kind: METHOD),
        #inc1: const Declaration(#inc1, Function, kind: METHOD),
        #inc2: const Declaration(#inc2, Function, kind: METHOD),
      },
      C: {
        #x: const Declaration(#x, int),
        #y: const Declaration(#y, String),
        #b: const Declaration(#b, B),
        #inc: const Declaration(#inc, Function, kind: METHOD),
      },
      C_with_A: {
        #i: const Declaration(#i, int),
        #j: const Declaration(#j, int),
        #j2: const Declaration(#j2, int, kind: PROPERTY),
        #inc0: const Declaration(#inc0, Function, kind: METHOD),
        #inc1: const Declaration(#inc1, Function, kind: METHOD),
        #inc2: const Declaration(#inc2, Function, kind: METHOD),
      },
      D: {
        #x2: const Declaration(#x2, int, kind: PROPERTY),
        #i2: const Declaration(#i2, int, kind: PROPERTY),
      },
      E: {
        #y: const Declaration(#y, int, isFinal: true, kind: PROPERTY),
        #noSuchMethod:
           const Declaration(#noSuchMethody, Function, kind: METHOD),
      },
      E2: const {},
      F: {#staticMethod: const Declaration(#staticMethod, Function,
             kind: METHOD, isStatic: true)},
      F2: const {},
      G: {
        #a: const Declaration(#a, int),
        #b: const Declaration(#b, int, annotations: const [a1]),
        #c: const Declaration(#c, int),
        #d: const Declaration(#d, int, annotations: const [a2]),
      },
      H: {
        #e: const Declaration(#e, int),
        #f: const Declaration(#f, int, annotations: const [a1]),
        #g: const Declaration(#g, int, annotations: const [a1]),
        #h: const Declaration(#h, int, annotations: const [a2]),
        #i: const Declaration(#i, int, annotations: const [a3]),
      },
    },
    names: {#i: 'i'});

main() {
  setUp(() => useGeneratedCode(_config));
  common.main();
}
